<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=1024, user-scalable=no">

  <title>TypeScript: JavaScript的超集</title>
  
  <!-- Required stylesheet -->
  <link rel="stylesheet" href="deck.js/core/deck.core.css">
  
  <!-- Extension CSS files go here. Remove or add as needed. -->
  <link rel="stylesheet" href="deck.js/extensions/goto/deck.goto.css">
  <link rel="stylesheet" href="deck.js/extensions/menu/deck.menu.css">
  <link rel="stylesheet" href="deck.js/extensions/navigation/deck.navigation.css">
  <link rel="stylesheet" href="deck.js/extensions/status/deck.status.css">
  <link rel="stylesheet" href="deck.js/extensions/hash/deck.hash.css">
  <link rel="stylesheet" href="deck.js/extensions/scale/deck.scale.css">

  <link rel="stylesheet" href="assets/typescript.css">
  
  <!-- Transition theme. More available in /themes/transition/ or create your own. -->
  <link rel="stylesheet" href="deck.js/themes/transition/horizontal-slide.css">
  
  <!-- Required Modernizr file -->
  <script src="deck.js/modernizr.custom.js"></script>
</head>
<body class="deck-container">

<!-- Begin slides. Just make elements with a class of slide. -->

<section class="slide" id="intro">
  <div><hgroup>
    <h1>TypeScript</h1>
    <h2>JavaScript的超集</h2>
	
	<h3>黄磊 <a href="mailto:huanglei13@meituan.com">huanglei13@meituan.com</a></h3>
  </hgroup></div>
</section>

<section class="slide">
  <h2>大纲</h2>
  <ul>
    <li><a href="#slide-2">设计初衷</a></li>
    <li><a href="#slide-5">工具支持</a></li>
    <li><a href="#slide-6">获取 TypeScript</a></li>
    <li><a href="#slide-7">tsconfig.json</a></li>
    <li><a href="#slide-8">文件拓展名</a></li>
    <li><a href="#slide-9">声明文件</a></li>
    <li><a href="#slide-10">类型批注</a></li>
    <li><a href="#slide-11">类型</a></li>
    <li><a href="#slide-12">函数类型</a></li>
    <li><a href="#slide-15">类</a></li>
    <li><a href="#slide-17">接口</a></li>
    <li><a href="#slide-19">枚举</a></li>
    <li><a href="#slide-20">范型</a></li>
    <li><a href="#slide-22">模块</a></li>
    <li><a href="#slide-24">命名空间</a></li>
    <li><a href="#slide-26">装饰器</a></li>
    <li><a href="#slide-29">DEMO演示</a></li>
    <li>总结
      <ul>
        <li><a href="#slide-30">为什么使用 TypeScript?</a></li>
        <li><a href="#slide-31">有什么理由不使用?</a></li>
      </ul>
    </li>
    <li><a href="#slide-33"></a>资源</li>
  </ul>
</section>

<section class="slide"> 
  <blockquote cite="http://www.typescriptlang.org/">
    <p>TypeScript is a language for application-scale JavaScript development.</p><br />
    <p>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.</p><br />
    <p>Any browser. Any host. Any OS. Open Source.</p>
    <p><cite>typescriptlang.org</cite></p>
  </blockquote>
</section>

<section class="slide"> 
  <h2>设计初衷</h2>
  <ul>    
    <li>为了编写大型应用而拓展的JavaScript的超集 (JavaScript的超集)。</li>
    <li>支持类，接口 &amp; 模块。</li>
    <li>强大的工具构建。</li>
    <li>编译出纯净、 简洁的JavaScript代码，并且可以运行在任何浏览器上、Node.js环境中。</li>
    <li>由于JavaScript代码也是TypeScript代码，所以你可以用渐进增强的方式选择你要的TypeScript特性。</li>   
  </ul>
</section>

<section class="slide">
  <blockquote>
    <p>What TypeScript does is, it basically formalizes a static type system that describes JavaScript's dynamic types, but it describes them at development time.</p>
    <p><cite>Anders Hejlsberg</cite></p>
  </blockquote>
  <p>本质上，TypeScript 是通过一套静态类型系统在开发阶段提供类型检查。</p>
</section>

<section class="slide"> 
  <h2>工具支持</h2>
  <ul>    
    <li>静态类型检查。</li>
    <li>强类型推断。</li>
    <li>代码导航。</li>
    <li>智能提示与语法补全。</li>
    <li>代码重构。</li>
  </ul>
  <p>目前支持 TypeScript 的ide有 <strong>Visual Studio 2012</strong>及以上、<strong>Visual Studio Code</strong>、<strong>Webstorm</strong>。</p>
  <p>网页编辑器有 TypeScript.org playground。</p>
  <p>另外, 也支持 Sublime Text、 EMACS、 Vim、 Atom等文本编辑器。</p>
</section>

<section class="slide">
  <h2>获取 TypeScript</h2>
  <h3>Node.js</h3>
  <p>安装</p>  
  <pre><code>npm install -g typescript</code></pre>
  
  <p>编译</p>
  <pre><code>tsc helloworld.ts</code></pre>
</section>

<section class="slide">
  <h2>tsconfig.json</h2>
  <ul>
    <li>不带任何输入文件的情况下调用tsc，编译器会从当前目录开始去查找tsconfig.json文件，逐级向上搜索父目录。</li>
    <li>不带任何输入文件的情况下调用tsc，且使用命令行参数<code>--project</code>（或-p）指定一个包含tsconfig.json文件的目录。</li>
    <li>tsconfig.json文件可以利用<code>extends</code>属性从另一个配置文件里继承配置。</li>
  </ul>
  <pre><code>{
    "compilerOptions": {
        "module": "system",
        "noImplicitAny": true,
        "removeComments": true,
        "outFile": "../../built/local/tsc.js",
        "sourceMap": true
    },
    "include": [
        "src/**/*"
    ],
    "exclude": [
        "node_modules",
        "**/*.spec.ts"
    ]
}</code></pre>
</section>

<section class="slide"> 
  <h2>文件拓展名</h2>
  <ul>
    <li><code>.ts</code> 是源代码文件的拓展名。</li>
    <li><code>.d.ts</code> 是声明文件的拓展名。</li>
  </ul>
</section>

<section class="slide">  
  <h2>声明文件</h2>
  <ul>
    <li>提供类型声明，与对应的源码区分开来。</li>
    <li>类似于C/C++的头文件..</li>
    <li>当用户在TypeScript项目中使用外部JavaScript库或者模块时，可以用声明文件来为该库或者模块声明一个TypeScript虚拟类型。</li>
    <li>提供类型安全、智能提示和编译错误。</li>
  </ul>
  <pre><code>declare var jQuery: (string) => any;</code></pre>
</section>

<section class="slide"> 
  <h2>类型批注</h2>
  <ul>
    <li>可选择的静态类型。</li>
    <li>为记录函数或者变量意图提供轻量化的方法</li>
    <li>使用 <em>后缀</em> 语法.</li>
    <li><code>: T</code> 是可选的。</li>
    <li>函数的返回类型可以被推导出来。</li>
    <li>支持联合类型 <code>|</code></li>
  </ul>
    <pre><code>function add(a: number, b: number, c:string|number, d?) {
    console.log(c,d);
    return a + b;
}</pre></code>
</section>

<section class="slide">
  <h2>类型</h2>
  <h3>Any</h3>
  <ul>
    <li>所有类型都是顶级类型<code>any</code> 类型的子类型。</li>
    <li>表示任意JavaScript value没有任何类型约束。</li>
  </ul>

  <h3>原始数据类型</h3>
  <ul>
    <li><code>number</code></li>
    <li><code>bool</code></li>
    <li><code>string</code></li>
    <li><code>null</code></li>
    <li><code>undefined</code></li>    
  </ul>
  <h3>Never</h3>
  <ul>
    <li><code>never</code>类型表示的是那些永不存在的值的类型。</li>
    <li>never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。</li>
  </ul>
  <h3>对象类型</h3>
  <ul>
    <li>类、模块、接口 和 字符串字面量类型。</li>
    <li>支持固定类型数组: <code>var reports: Employee[] = [];</code></li>
  </ul>  
</section>

<section class="slide">
  <h2>类型保护</h2>
  <p>类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型 保护，我们只要简单地定义一个函数，它的返回值是一个类型谓词</p>
  <p>谓词为parameterName is Type这种形式，parameterName必须是来自于当前函数签名里的一个参数名。</p>
  <pre><code>function isFish(pet: Fish | Bird): pet is Fish {
    return (<Fish>pet).swim !== undefined;
}</code></pre>
  <div class="slide">
    <h3>typeof类型保护</h3>
    <ul>
      <li>typeof v === "typename"</li>
      <li>typeof v !== "typename"</li>
      <li>"typename"必须是"number"，"string"，"boolean"或"symbol"</li>
    </ul>
  </div>
    <div class="slide">
    <h3>instanceof类型保护</h3>
    <p>instanceof的右侧要求是一个构造函数，TypeScript将细化为: 此构造函数的prototype属性的类型。</p>
  </div>
</section>

<section class="slide"> 
  <h2>函数类型</h2>
  
  <div class="slide">
    <h3>函数表达式</h3>
    <pre><code>let mySum: (x: number, y: number) => number = function (x: number, y: number): number {
  return x + y;
};</pre></code>
  </div>
  
  <div class="slide">
    <h3>接口中函数的定义</h3>
    <pre><code>interface SearchFunc {
  (source: string, subString: string): boolean;
}

let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
  return source.search(subString) !== -1;
}</pre></code>
  </div>
</section>

<section class="slide"> 
  <h2>类</h2>
  <ul>    
    <li>支持类似于 ECMAScript 6 语法的类。</li>
    <li>支持<code>public</code> 或者 <code>private</code> 成员。</li>
    <li>通过构造器声明参数属性。</li>
    <li>支持单父类继承。</li>
    <li>子类通过使用 <code>super</code> 调用父类。</li>
  </ul>
</section>

<section class="slide">
  <h2>类</h2>
  <pre><code class="typescript">class Animal {
    constructor(public name) { }
    move(meters) {
        alert(this.name + " moved " + meters + "m.");
    }
}

class Snake extends Animal {
  move() {
    alert("Slithering...");
    super.move(5);
  }
}

class Horse extends Animal {
  move() {
    alert("Galloping...");
    super.move(45);
  }
}</pre></code>
</section>

<section class="slide"> 
  <h2>接口</h2>
  <ul>    
    <li>只有开发工具支持。</li>
    <li>不会被编译成JavaScript代码。</li>
    <li>结构化的类型系统-接口是由任何符合结构的对象/原型自动实现的。</li>
    <li>支持通过参数签名来重载。</li>
    <li>可拓展 (可能在多个文件里都有声明).</li>
    <li>支持多接口实现。</li>
  </ul>
  <p>TypeScript结构化类型系统的基本规则是，如果x要兼容y，那么y至少具有与x相同的属性</p>
</section>

<section class="slide">
  <h2>接口</h2>
  <pre><code class="typescript">interface Vehicle {
    wheel: number;
}

interface Drivable {
    start(): void;
    drive(distance: number): void;
    getPosition(): number;
}

class Car implements Drivable, Vehicle {
    public wheel = 4;
    private isRunning = false;
    private distanceFromStart: number;

    public start(): void {
        this.isRunning = true;
    }
    public drive(distance: number): void {
        if (this.isRunning) {
            this.distanceFromStart += distance;
        }
    }
    public getPosition(): number {
        return this.distanceFromStart;
    }
}
</pre></code>
<p><strong>注意</strong> 接口没有 <em>运行时</em> 的表达 - 他们只是纯粹的 <em>编译时</em> 结构.</p>
</section>

<section class="slide">
  <h2>枚举</h2>
  <ul>
    <li>一个枚举类型可以包含零个或多个枚举成员。</li>
    <li>枚举成员具有一个值，它可以是常数或是计算得出的值</li>
    <li>枚举是在运行时真正存在的一个对象。这样可以从枚举值到枚举名进行反向映射。</li>
  </ul>
  <pre><code class="typescript">enum Direction {
    Up,
    Down,
    Left,
    Right
}

var up = Direction.Up;</pre></code>
</section>

<section class="slide"> 
  <h2>范型</h2>
  <ul>
    <li>创建一致的定义良好的API，同时也要考虑可重用性。</li>
    <li>使用<strong>类型变量</strong> ，它是一种特殊的变量，只用于表示类型而不是值</li>
    <li>在使用范性的时候，支持类型推断</li>
    <li>使用 <strong>泛型约束</strong> 来表示想操作某类型的一组值</li>
  </ul>  
</section>


<section class="slide">
  <h2>范型</h2>
  <pre><code>// 检查带有length属性的对象
interface Lengthwise {
    length: number;
}

function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {
    console.log(arg.length);
    return arg;
}
loggingIdentity({length: 10, value: 3});</pre></code>
</section>

<section class="slide"> 
  <h2>模块</h2>
  <ul>
    <li>大体上同ECMAScript 2015模块。</li>
    <li>任何声明（比如变量，函数，类，类型别名或接口）都能够通过添加export关键字来导出。</li>
    <li>使用import来导入其它模块中的导出内容。</li>
    <li>模块在其自身的作用域里执行，而不是在全局作用域里。</li>
  </ul>
  
  <div class="slide">
    <h3>使用其它的JavaScript库</h3>
    <h4>外部模块（简写）</h4>
    <ul>
      <li>要想描述非TypeScript编写的类库的类型，我们需要声明类库所暴露出的API。</li>
      <li>简写模块里所有导出的类型将是any。</li>
    </ul>
    <pre><code>declare module "hot-new-module";</code></pre>

    <h4>模块声明通配符</h4>
    <p>某些模块加载器如SystemJS 和AMD支持导入非JavaScript内容。  模块声明通配符可以用来表示这些情况。</p>
    <pre><code>declare module "*!text" {
    const content: string;
    export default content;
  }
// Some do it the other way around.
declare module "json!*" {
    const value: any;
    export default value;
}
import fileContent from "./xyz.txt!text";
import data from "json!http://example.com/data.json";</pre></code>
  </div>
</section>

<section class="slide">
  <h2>命名空间</h2>
  <ul>
    <li>当应用变得越来越大时，我们需要将代码分离到不同的文件中以便于维护。</li>
    <li> 尽管是不同的文件，它们仍是同一个命名空间，并且在使用的时候就如同它们在一个文件中定义的一样。</li>
    <li> 因为不同文件之间存在依赖关系，所以需要加入了引用标签来告诉编译器文件之间的关联。</li>
  </ul>
  <div class="slide">
      <p>Validation.ts</p>
  <pre><code>namespace Validation {
  export interface StringValidator {
      isAcceptable(s: string): boolean;
  }
}</code></pre>
  <p>LettersOnlyValidator.ts</p>
  <pre><code>/// &lt;reference path="Validation.ts" /&gt;
namespace Validation {
  const lettersRegexp = /^[A-Za-z]+$/;
  export class LettersOnlyValidator implements StringValidator {
      isAcceptable(s: string) {
          return lettersRegexp.test(s);
      }
  }
}</code></pre>
  <p>Test.ts</p>
  <pre><code>/// &lt;reference path="Validation.ts" /&gt;
/// &lt;reference path="LettersOnlyValidator.ts" /&gt;

//[s: string]可索引类型，s为索引签名
//这个索引签名表示了当用string去索引validators时
//会得到Validation.StringValidator类型的返回值。
let validators: { [s: string]: Validation.StringValidator; } = {};
validators["Letters only"] = new Validation.LettersOnlyValidator();</code></pre>
  </div>
</section>

<section class="slide">
  <h2>装饰器</h2>
  <ul>
    <li>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法，访问符，属性或参数上。 </li>
    <li>
      <p>若要启用实验性的装饰器特性，你必须在命令行或tsconfig.json里启用experimentalDecorators编译器选项：</p>
      <p>命令行:</p>
      <pre><code>tsc --target ES5 --experimentalDecorators</code></pre>
      <p>tsconfig.json:</p>
      <pre><code>{
    "compilerOptions": {
        "target": "ES5",
        "experimentalDecorators": true
    }
}</code></pre>
    </li>
    <li>装饰器使用<code>@expression</code>这种形式，<strong>expression</strong>求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。</li>
    <li>支持装饰器组合：<pre><code>@f
@g
x</code></pre>
求值方式与复合函数相似：(f ∘ g)(x)等同于f(g(x))
    </li>
  </ul>
</section>

<section class="slide">
  <h2>装饰器</h2>
  <pre><code>// 装饰器工厂f
  function f() {
    console.log("f(): evaluated");
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("f(): called");
    }
}

// 装饰器工厂g
function g() {
    console.log("g(): evaluated");
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("g(): called");
    }
}

class C {
    @f()
    @g()
    method() {}
}</code></pre>
</section>

<section class="slide">
  <h2>装饰器</h2>
  <pre><code>var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function f() {
    console.log("f(): evaluated");
    return function (target, propertyKey, descriptor) {
        console.log("f(): called");
    };
}
function g() {
    console.log("g(): evaluated");
    return function (target, propertyKey, descriptor) {
        console.log("g(): called");
    };
}
var C = (function () {
    function C() {
    }
    C.prototype.method = function () { };
    return C;
}());
__decorate([
    f(),
    g()
], C.prototype, "method", null);
</code></pre>
</section>

<section class="slide">
  <h2>Show Me The Code</h2>
  <h3><a href="http://localhost:3000/">DEMO</a></h3>
  <p>目录结构</p>
  <pre><code>.
├── dist
├── index.html
├── package.json
├── src
│   ├── index.ts
│   ├── interface.ts
│   ├── main.css
│   ├── particle.ts
│   ├── renderer.ts
│   └── strategy.ts
├── tsconfig.json
└── webpack.config.js</code></pre>
<p>tsconfig.json</p>
<pre><code>{
    "compilerOptions": {
        "outDir": "./dist/",
        "noImplicitAny": true,
        "module": "commonjs",
        "target": "es5",
        "sourceMap": true
    },
    "exclude": [
        "node_modules"
    ],
    "include": [
        "./src/*"
    ]
}</code></pre>
</section>

<section class="slide"> 
  <h2>为什么使用 TypeScript?</h2>
  <ul>
    <li>完全支持 ECMAScript 6 语法 ，能编译为 ECMAScript 3。</li>   
    <li>开源, 使用 Apache 2.0 许可证。</li>
    <li>完整的工具支持。团队对issue的响应快速。</li>
    <li>静态类型和编译帮助更早地捕获 错误&amp;bug。</li> 
    <li>结构化的 类型 &amp; 接口。</li>
    <li>能对已有的项目进行渐进增强式地重构</li> 
    <li>牛逼的团队：<a href="https://www.linkedin.com/in/steve-lucco-b5084958/">Steve Lucco</a>、<a href="https://en.wikipedia.org/wiki/Anders_Hejlsberg">Anders Hejlsberg</a>等人。</li>
    <li>对大型项目非常友好。</li>    
  </ul>
</section>

<section class="slide"> 
  <h2>有什么理由不使用?</h2>
  <ul>
    <li>增加项目开发的复杂度。</li>
    <li>对涉及DOM、BOM的代码编写比较麻烦。</li>  
  </ul>
</section>

<section class="slide">
  <blockquote>
    <p>静态类型确实有一些相对性的价值。</p>
    <p>通常情况下，它是以牺牲灵活性为代价的，但这给JavaScript以可选的方式带来了很多好处，这是非常强大的。</p>    
  </blockquote>
</section>

<section class="slide">
  <h2>资源</h2>
  <ul>
    <li><a href="http://www.typescriptlang.org/">typescriptlang.org</a></li>
    <li><a href="http://go.microsoft.com/fwlink/?LinkId=267238">官方手册</a></li>
  </ul>

  <h2>Questions...?</h2>
</section>

<!-- End slides. -->

<!-- Begin extension snippets. Add or remove as needed. -->

<!-- deck.navigation snippet
<a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
<a href="#" class="deck-next-link" title="Next">&#8594;</a> 
-->

<!-- deck.status snippet -->
<p class="deck-status">
  <span class="deck-status-current"></span>
  /
  <span class="deck-status-total"></span>
</p>

<!-- deck.goto snippet -->
<form action="." method="get" class="goto-form">
  <label for="goto-slide">Go to slide:</label>
  <input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
  <datalist id="goto-datalist"></datalist>
  <input type="submit" value="Go">
</form>

<!-- deck.hash snippet -->
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>

<!-- End extension snippets. -->


<!-- Required JS files. -->
<script src="deck.js/jquery-1.7.2.min.js"></script>
<script src="deck.js/core/deck.core.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="deck.js/core/deck.core.js"></script>
<script src="deck.js/extensions/hash/deck.hash.js"></script>
<script src="deck.js/extensions/menu/deck.menu.js"></script>
<script src="deck.js/extensions/goto/deck.goto.js"></script>
<script src="deck.js/extensions/status/deck.status.js"></script>
<script src="deck.js/extensions/navigation/deck.navigation.js"></script>
<script src="deck.js/extensions/scale/deck.scale.js"></script>

<!-- Suport for compiling TypeScript -->
<script src="assets/typescript.min.js"></script>
<script src="assets/compiler.js"></script>

<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
  $(function() {
    $.deck('.slide');

    var compiler = new Compiler();

    $(document).bind('deck.change', function(event, from, to) {
      var fromSlide = $.deck('getSlide', from);

      var tsCode = $(fromSlide).find('code.typescript');
      var jsCode = $(fromSlide).find('code.javascript');

      var goingForwards = to > from;
      var goingBackwards = from > to;

      if (goingBackwards === true && jsCode.length > 0) {
        // Replace TypeScript with JavaScript source
        jsCode.remove();
        tsCode.show();

        $.deck('toggleScale');
        $.deck('toggleScale');

        event.preventDefault();
        return false;
      } else if (goingForwards == true && tsCode.not(':hidden').length > 0) {
        var src = tsCode.map(function() { 
          return $(this).text(); 
        }).get().join('\n');
        // Conpile TypeScript to JavaScript

        var typescript = compiler.compile(src);

        var copy = tsCode.clone().addClass('javascript').removeClass('typescript').text(typescript);
        tsCode.parent().append(copy);
        tsCode.hide();

        $.deck('toggleScale');
        $.deck('toggleScale');

        event.preventDefault();
        return false;
      }
    });
  });
</script>
</body>
</html>